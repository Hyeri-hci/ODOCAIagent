"""
NVD (National Vulnerability Database) Client
NVD APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì·¨ì•½ì  ì •ë³´ë¥¼ ì¡°íšŒí•˜ëŠ” í´ë¼ì´ì–¸íŠ¸

ì£¼ìš” ê¸°ëŠ¥:
- Product/Version ê¸°ë°˜ ì·¨ì•½ì  ì¡°íšŒ
- CPE (Common Platform Enumeration) ìƒì„± ë° ì¡°íšŒ
- ì·¨ì•½ì  ìƒì„¸ ì •ë³´ íŒŒì‹± (CVSS, CWE, ì„¤ëª… ë“±)
- ê²°ê³¼ í¬ë§·íŒ… ë° í†µê³„
"""

import os
import requests
from dotenv import load_dotenv
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import time
import asyncio
import aiohttp
from .cpe_mapper import get_cpe_mapper


class NvdClient:
    """NVD API í´ë¼ì´ì–¸íŠ¸"""

    def __init__(self, api_key: Optional[str] = None):
        """
        ì´ˆê¸°í™”

        Args:
            api_key: NVD API í‚¤ (ì„ íƒì , ì—†ìœ¼ë©´ .envì—ì„œ ë¡œë“œ)
        """
        load_dotenv()

        self.NVD_BASE_URL = os.getenv('NVD_BASE_URL', 'https://services.nvd.nist.gov/rest/json/cves/2.0')
        self.NVD_API_KEY = api_key or os.getenv('NVD_API_KEY')

        self.headers = {
            "Accept": "application/json",
            "User-Agent": "SecurityAgent/2.0",
        }

        if self.NVD_API_KEY:
            self.headers["apiKey"] = self.NVD_API_KEY
        else:
            print("[NvdClient] Warning: No API key provided. Rate limits will apply (5 requests per 30 seconds)")

        # Rate limiting (ê°œì„ : 1ë¶„ì— 30ê°œ ìš”ì²­ = 2ì´ˆë‹¹ 1ê°œ)
        self.last_request_time = 0
        self.min_request_interval = 6 if not self.NVD_API_KEY else 2.0  # 6ì´ˆ or 2ì´ˆ

        # CPE Mapper ì¸ìŠ¤í„´ìŠ¤
        self.cpe_mapper = get_cpe_mapper()

        # ë¹„ë™ê¸° ì„¸ë§ˆí¬ì–´ (ë™ì‹œ ìš”ì²­ ìˆ˜ ì œí•œ)
        self._semaphore = None
        self._request_times = []  # ìš”ì²­ ì‹œê°„ ì¶”ì  (1ë¶„ ìœˆë„ìš°)

    def _rate_limit(self):
        """Rate limiting ì²˜ë¦¬"""
        elapsed = time.time() - self.last_request_time
        if elapsed < self.min_request_interval:
            sleep_time = self.min_request_interval - elapsed
            print(f"[NvdClient] Rate limiting: sleeping {sleep_time:.1f}s")
            time.sleep(sleep_time)
        self.last_request_time = time.time()

    def __convert_to_cpe_uri(
        self,
        product: str,
        version: str = '*',
        part: str = 'a',
        vendor: str = '*'
    ) -> str:
        """
        CPE URI ìƒì„±

        Args:
            product: ì œí’ˆëª… (ì˜ˆ: node.js, react)
            version: ë²„ì „ (ì˜ˆ: 1.2.3, *ëŠ” ëª¨ë“  ë²„ì „)
            part: íƒ€ì… (a: application, o: os, h: hardware)
            vendor: ë²¤ë” (ì˜ˆ: microsoft, apache, *ëŠ” ëª¨ë“  ë²¤ë”)

        Returns:
            CPE 2.3 URI
        """
        cpe = f"cpe:2.3:{part}:{vendor}:{product}:{version}"
        return cpe

    def get_product_vulnerabilities(
        self,
        product: str,
        version: str = '*',
        part: str = 'a',
        vendor: str = '*',
        results_per_page: int = 100
    ) -> Dict[str, Any]:
        """
        Product/Version ê¸°ë°˜ ì·¨ì•½ì  ì¡°íšŒ

        Args:
            product: ì œí’ˆëª…
            version: ë²„ì „ (ê¸°ë³¸ê°’: * = ëª¨ë“  ë²„ì „)
            part: CPE íŒŒíŠ¸ (ê¸°ë³¸ê°’: a = application)
            vendor: ë²¤ë”ëª… (ê¸°ë³¸ê°’: * = ëª¨ë“  ë²¤ë”)
            results_per_page: í˜ì´ì§€ë‹¹ ê²°ê³¼ ìˆ˜ (ìµœëŒ€ 2000)

        Returns:
            {
                "success": bool,
                "vulnerabilities": List[Dict],
                "total_count": int,
                "cpe_uri": str,
                "error": str (ì‹¤íŒ¨ ì‹œ)
            }
        """
        # 1. DBì—ì„œ CPE ë§¤í•‘ ì¡°íšŒ
        cpe_uri = self.cpe_mapper.get_cpe_for_package(
            package_name=product,
            version=version
        )

        # 2. DBì— ë§¤í•‘ì´ ì—†ìœ¼ë©´ fallbackìœ¼ë¡œ ìë™ ìƒì„±
        if cpe_uri is None:
            print(f"[NvdClient] No DB mapping, using fallback CPE generation for: {product}")
            cpe_uri = self.__convert_to_cpe_uri(
                product=product,
                version=version,
                part=part,
                vendor=vendor
            )

        print(f"[NvdClient] Searching vulnerabilities for CPE: {cpe_uri}")

        params = {
            "virtualMatchString": cpe_uri,
            "resultsPerPage": results_per_page
        }

        try:
            self._rate_limit()
            response = requests.get(
                url=self.NVD_BASE_URL,
                params=params,
                headers=self.headers,
                timeout=30
            )
            response.raise_for_status()

            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])

            print(f"[NvdClient] Found {len(vulnerabilities)} vulnerabilities")

            # ì·¨ì•½ì  íŒŒì‹±
            parsed_vulns = [self._parse_vulnerability(v) for v in vulnerabilities]

            return {
                "success": True,
                "vulnerabilities": parsed_vulns,
                "total_count": len(parsed_vulns),
                "cpe_uri": cpe_uri,
                "product": product,
                "version": version
            }

        except requests.exceptions.HTTPError as e:
            error_msg = f"HTTP Error {e.response.status_code}: {e.response.text}"
            print(f"[NvdClient] Error: {error_msg}")
            return {
                "success": False,
                "error": error_msg,
                "vulnerabilities": [],
                "total_count": 0,
                "cpe_uri": cpe_uri
            }

        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}"
            print(f"[NvdClient] Error: {error_msg}")
            return {
                "success": False,
                "error": error_msg,
                "vulnerabilities": [],
                "total_count": 0,
                "cpe_uri": cpe_uri
            }

    def get_vulnerabilities_before_n_days(self, days: int = 7) -> Dict[str, Any]:
        """
        ìµœê·¼ Nì¼ ì´ë‚´ ë°œê²¬ëœ ì·¨ì•½ì  ì¡°íšŒ

        Args:
            days: ìµœê·¼ ì¼ìˆ˜ (ê¸°ë³¸ê°’: 7ì¼)

        Returns:
            {
                "success": bool,
                "vulnerabilities": List[Dict],
                "total_count": int,
                "start_date": str,
                "end_date": str,
                "error": str (ì‹¤íŒ¨ ì‹œ)
            }
        """
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)

        start_str = start_date.strftime("%Y-%m-%dT00:00:00.000")
        end_str = end_date.strftime("%Y-%m-%dT23:59:59.999")

        print(f"[NvdClient] Searching vulnerabilities from {start_str} to {end_str}")

        params = {
            "pubStartDate": start_str,
            "pubEndDate": end_str,
            "resultsPerPage": 100
        }

        try:
            self._rate_limit()
            response = requests.get(
                url=self.NVD_BASE_URL,
                params=params,
                headers=self.headers,
                timeout=30
            )
            response.raise_for_status()

            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])

            # ì·¨ì•½ì  íŒŒì‹±
            parsed_vulns = [self._parse_vulnerability(v) for v in vulnerabilities]

            return {
                "success": True,
                "vulnerabilities": parsed_vulns,
                "total_count": len(parsed_vulns),
                "start_date": start_str,
                "end_date": end_str
            }

        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}"
            print(f"[NvdClient] Error: {error_msg}")
            return {
                "success": False,
                "error": error_msg,
                "vulnerabilities": [],
                "total_count": 0,
                "start_date": start_str,
                "end_date": end_str
            }

    def _parse_vulnerability(self, vuln_data: Dict) -> Dict[str, Any]:
        """
        ì·¨ì•½ì  ë°ì´í„° íŒŒì‹±

        Args:
            vuln_data: NVD API ì‘ë‹µì˜ vulnerability ê°ì²´

        Returns:
            íŒŒì‹±ëœ ì·¨ì•½ì  ì •ë³´
        """
        cve = vuln_data.get("cve", {})

        # CVE ID
        cve_id = cve.get("id", "N/A")

        # ì„¤ëª… ì¶”ì¶œ
        descriptions = cve.get("descriptions", [])
        description = next(
            (d["value"] for d in descriptions if d.get("lang") == "en"),
            descriptions[0]["value"] if descriptions else "No description available"
        )

        # CVSS ì ìˆ˜ ì¶”ì¶œ
        metrics = cve.get("metrics", {})
        cvss_data = self._extract_cvss(metrics)

        # ì˜í–¥ë°›ëŠ” ì œí’ˆ (CPE)
        configurations = cve.get("configurations", [])
        cpes = self._extract_cpes(configurations)

        # CWE (ì·¨ì•½ì  ìœ í˜•)
        weaknesses = cve.get("weaknesses", [])
        cwes = self._extract_cwes(weaknesses)

        # ë°œí‘œì¼/ìˆ˜ì •ì¼
        published = cve.get("published", "")
        modified = cve.get("lastModified", "")

        # ì°¸ì¡° ë§í¬
        references = cve.get("references", [])
        refs = [ref.get("url") for ref in references][:5]  # ìƒìœ„ 5ê°œë§Œ

        return {
            "cve_id": cve_id,
            "description": description,
            "cvss_v3_score": cvss_data.get("cvss_v3_score"),
            "cvss_v3_severity": cvss_data.get("cvss_v3_severity"),
            "cvss_v2_score": cvss_data.get("cvss_v2_score"),
            "cvss_v2_severity": cvss_data.get("cvss_v2_severity"),
            "severity": cvss_data.get("severity", "UNKNOWN"),  # ì¢…í•© ì‹¬ê°ë„
            "cpes": cpes,
            "cwes": cwes,
            "published": published,
            "modified": modified,
            "references": refs
        }

    def _extract_cvss(self, metrics: Dict) -> Dict[str, Any]:
        """CVSS ì ìˆ˜ ì¶”ì¶œ"""
        result = {
            "cvss_v3_score": None,
            "cvss_v3_severity": None,
            "cvss_v2_score": None,
            "cvss_v2_severity": None,
            "severity": "UNKNOWN"
        }

        # CVSS v3.x (ìš°ì„ ìˆœìœ„)
        cvss_v3 = metrics.get("cvssMetricV31") or metrics.get("cvssMetricV30")
        if cvss_v3 and len(cvss_v3) > 0:
            cvss_data = cvss_v3[0].get("cvssData", {})
            result["cvss_v3_score"] = cvss_data.get("baseScore")
            result["cvss_v3_severity"] = cvss_data.get("baseSeverity")
            result["severity"] = cvss_data.get("baseSeverity", "UNKNOWN")

        # CVSS v2 (fallback)
        cvss_v2 = metrics.get("cvssMetricV2")
        if cvss_v2 and len(cvss_v2) > 0:
            cvss_data = cvss_v2[0].get("cvssData", {})
            result["cvss_v2_score"] = cvss_data.get("baseScore")
            result["cvss_v2_severity"] = cvss_v2[0].get("baseSeverity")

            # v3ê°€ ì—†ìœ¼ë©´ v2 ì‚¬ìš©
            if not result["cvss_v3_score"]:
                result["severity"] = cvss_v2[0].get("baseSeverity", "UNKNOWN")

        return result

    def _extract_cpes(self, configurations: List[Dict]) -> List[str]:
        """CPE ì¶”ì¶œ"""
        cpes = []
        for config in configurations:
            nodes = config.get("nodes", [])
            for node in nodes:
                cpe_match = node.get("cpeMatch", [])
                for match in cpe_match:
                    if match.get("vulnerable", False):
                        cpe_uri = match.get("criteria")
                        if cpe_uri:
                            cpes.append(cpe_uri)
        return cpes[:10]  # ìƒìœ„ 10ê°œë§Œ

    def _extract_cwes(self, weaknesses: List[Dict]) -> List[str]:
        """CWE ì¶”ì¶œ"""
        cwes = []
        for weakness in weaknesses:
            descriptions = weakness.get("description", [])
            for desc in descriptions:
                if desc.get("lang") == "en":
                    cwe_id = desc.get("value", "")
                    if cwe_id.startswith("CWE-"):
                        cwes.append(cwe_id)
        return cwes

    def get_vulnerability_by_cve_id(self, cve_id: str) -> Dict[str, Any]:
        """
        CVE IDë¡œ ì·¨ì•½ì  ì¡°íšŒ

        Args:
            cve_id: CVE ID (ì˜ˆ: CVE-2021-44228)

        Returns:
            ì·¨ì•½ì  ìƒì„¸ ì •ë³´
        """
        print(f"[NvdClient] Fetching details for {cve_id}")

        params = {"cveId": cve_id}

        try:
            self._rate_limit()
            response = requests.get(
                url=self.NVD_BASE_URL,
                params=params,
                headers=self.headers,
                timeout=30
            )
            response.raise_for_status()

            data = response.json()
            vulnerabilities = data.get("vulnerabilities", [])

            if vulnerabilities:
                return {
                    "success": True,
                    "vulnerability": self._parse_vulnerability(vulnerabilities[0])
                }
            else:
                return {
                    "success": False,
                    "error": f"CVE {cve_id} not found"
                }

        except Exception as e:
            return {
                "success": False,
                "error": f"{type(e).__name__}: {str(e)}"
            }

    async def _async_rate_limit(self):
        """ë¹„ë™ê¸° Rate limiting (1ë¶„ì— 30ê°œ ì œí•œ)"""
        current_time = time.time()

        # 1ë¶„ ì´ë‚´ì˜ ìš”ì²­ë§Œ ìœ ì§€
        self._request_times = [t for t in self._request_times if current_time - t < 60]

        # 1ë¶„ ì•ˆì— 30ê°œ ì´ìƒì´ë©´ ëŒ€ê¸°
        if len(self._request_times) >= 30:
            oldest_request = self._request_times[0]
            wait_time = 60 - (current_time - oldest_request) + 0.1
            if wait_time > 0:
                print(f"[NvdClient] Rate limit: waiting {wait_time:.1f}s (30 requests/min)")
                await asyncio.sleep(wait_time)
                current_time = time.time()

        # ìµœì†Œ ê°„ê²© ëŒ€ê¸°
        if self._request_times:
            last_request = self._request_times[-1]
            elapsed = current_time - last_request
            if elapsed < self.min_request_interval:
                wait_time = self.min_request_interval - elapsed
                await asyncio.sleep(wait_time)

        # í˜„ì¬ ìš”ì²­ ì‹œê°„ ê¸°ë¡
        self._request_times.append(time.time())

    async def _async_get_product_vulnerabilities(
        self,
        session: aiohttp.ClientSession,
        product: str,
        version: str = '*',
        part: str = 'a',
        vendor: str = '*'
    ) -> Dict[str, Any]:
        """
        ë¹„ë™ê¸° Product/Version ê¸°ë°˜ ì·¨ì•½ì  ì¡°íšŒ
        """
        # 1. DBì—ì„œ CPE ë§¤í•‘ ì¡°íšŒ
        cpe_uri = self.cpe_mapper.get_cpe_for_package(
            package_name=product,
            version=version
        )

        # 2. DBì— ë§¤í•‘ì´ ì—†ìœ¼ë©´ fallbackìœ¼ë¡œ ìë™ ìƒì„±
        if cpe_uri is None:
            cpe_uri = self.__convert_to_cpe_uri(
                product=product,
                version=version,
                part=part,
                vendor=vendor
            )

        params = {
            "virtualMatchString": cpe_uri,
            "resultsPerPage": 100
        }

        try:
            await self._async_rate_limit()

            async with session.get(
                url=self.NVD_BASE_URL,
                params=params,
                headers=self.headers,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                response.raise_for_status()
                data = await response.json()
                vulnerabilities = data.get("vulnerabilities", [])

                # ì·¨ì•½ì  íŒŒì‹±
                parsed_vulns = [self._parse_vulnerability(v) for v in vulnerabilities]

                return {
                    "success": True,
                    "vulnerabilities": parsed_vulns,
                    "total_count": len(parsed_vulns),
                    "cpe_uri": cpe_uri,
                    "product": product,
                    "version": version
                }

        except Exception as e:
            error_msg = f"{type(e).__name__}: {str(e)}"
            return {
                "success": False,
                "error": error_msg,
                "vulnerabilities": [],
                "total_count": 0,
                "cpe_uri": cpe_uri
            }

    async def _async_analyze_dependency_vulnerabilities(
        self,
        dependencies: Dict[str, List[Dict]],
        skip_unmapped: bool = True
    ) -> Dict[str, Any]:
        """
        ë¹„ë™ê¸° ì˜ì¡´ì„± ëª©ë¡ì— ëŒ€í•œ ì·¨ì•½ì  ë¶„ì„ (ë³‘ë ¬ ì²˜ë¦¬)
        """
        print(f"[NvdClient] Analyzing vulnerabilities for dependencies (async)...")
        print(f"[NvdClient] Skip unmapped packages: {skip_unmapped}")

        all_vulnerabilities = []
        severity_counts = {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0,
            "UNKNOWN": 0
        }

        packages_scanned = 0
        packages_skipped = 0
        packages_with_vulns = 0
        total_packages = sum(len(packages) for packages in dependencies.values())

        # 1ë‹¨ê³„: DBì—ì„œ CPE ë§¤í•‘ ë°°ì¹˜ ì¡°íšŒ
        cpe_mappings = {}
        if skip_unmapped and self.cpe_mapper:
            print(f"[NvdClient] Pre-fetching CPE mappings from DB...")

            for ecosystem, packages in dependencies.items():
                for pkg in packages:
                    name = pkg.get("name")
                    version = pkg.get("version", "*")

                    if name:
                        cpe_uri = self.cpe_mapper.get_cpe_for_package(name, version, ecosystem)
                        if cpe_uri:
                            cpe_mappings[name] = cpe_uri

            print(f"[NvdClient] Found {len(cpe_mappings)}/{total_packages} packages in CPE DB")

        # 2ë‹¨ê³„: ë¹„ë™ê¸°ë¡œ ì·¨ì•½ì  ì¡°íšŒ (ë³‘ë ¬ ì²˜ë¦¬)
        async with aiohttp.ClientSession() as session:
            tasks = []
            package_info_list = []

            for ecosystem, packages in dependencies.items():
                for pkg in packages:
                    name = pkg.get("name")
                    version = pkg.get("version", "*")

                    # skip_unmappedê°€ Trueì´ê³  DBì— ë§¤í•‘ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ
                    if skip_unmapped and self.cpe_mapper and name not in cpe_mappings:
                        packages_skipped += 1
                        continue

                    # ë¹„ë™ê¸° íƒœìŠ¤í¬ ìƒì„±
                    task = self._async_get_product_vulnerabilities(
                        session=session,
                        product=name,
                        version=version
                    )
                    tasks.append(task)
                    package_info_list.append({"name": name, "version": version, "ecosystem": ecosystem})

            packages_scanned = len(tasks)
            print(f"[NvdClient] Starting {packages_scanned} parallel vulnerability scans...")

            # ëª¨ë“  íƒœìŠ¤í¬ ì‹¤í–‰ (ë³‘ë ¬)
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # ê²°ê³¼ ì²˜ë¦¬
            for idx, result in enumerate(results):
                if isinstance(result, Exception):
                    print(f"[NvdClient] Error scanning package: {result}")
                    continue

                if result.get("success"):
                    vulns = result.get("vulnerabilities", [])

                    if vulns:
                        packages_with_vulns += 1

                    # ê° ì·¨ì•½ì ì— íŒ¨í‚¤ì§€ ì •ë³´ ì¶”ê°€
                    pkg_info = package_info_list[idx]
                    for vuln in vulns:
                        vuln["package_name"] = pkg_info["name"]
                        vuln["package_version"] = pkg_info["version"]
                        vuln["ecosystem"] = pkg_info["ecosystem"]

                        # ì‹¬ê°ë„ ì¹´ìš´íŠ¸
                        severity = vuln.get("severity", "UNKNOWN")
                        severity_counts[severity] = severity_counts.get(severity, 0) + 1

                    all_vulnerabilities.extend(vulns)

                # ì§„í–‰ ìƒí™© ë¡œê·¸
                if (idx + 1) % 10 == 0 or (idx + 1) == len(results):
                    print(f"[NvdClient] Progress: {idx + 1}/{len(results)} completed, {len(all_vulnerabilities)} vulnerabilities found")

        print(f"[NvdClient] Scan complete: {packages_with_vulns}/{packages_scanned} packages had vulnerabilities")

        if packages_skipped > 0:
            print(f"[NvdClient] Skipped {packages_skipped} packages (not in CPE DB)")

        # í†µê³„ ê³„ì‚°
        total_count = len(all_vulnerabilities)

        # ì‹¬ê°ë„ë³„ ì •ë ¬
        all_vulnerabilities.sort(
            key=lambda v: self._severity_priority(v.get("severity", "UNKNOWN"))
        )

        return {
            "success": True,
            "vulnerabilities": all_vulnerabilities,
            "total_count": total_count,
            "packages_checked": total_packages,
            "packages_scanned": packages_scanned,
            "packages_skipped": packages_skipped,
            "packages_with_vulnerabilities": packages_with_vulns,
            "severity_counts": severity_counts,
            "summary": self._generate_summary(all_vulnerabilities, severity_counts)
        }

    def analyze_dependency_vulnerabilities(
        self,
        dependencies: Dict[str, List[Dict]],
        skip_unmapped: bool = True
    ) -> Dict[str, Any]:
        """
        ì˜ì¡´ì„± ëª©ë¡ì— ëŒ€í•œ ì·¨ì•½ì  ë¶„ì„ (ë¹„ë™ê¸° ë²„ì „ ë˜í¼)

        Args:
            dependencies: {
                "npm": [{"name": "lodash", "version": "4.17.0"}, ...],
                "pypi": [{"name": "requests", "version": "2.25.0"}, ...]
            }
            skip_unmapped: DBì— ë§¤í•‘ì´ ì—†ëŠ” íŒ¨í‚¤ì§€ë¥¼ ìŠ¤í‚µí• ì§€ ì—¬ë¶€ (ê¸°ë³¸ê°’: True)

        Returns:
            ì¢…í•© ì·¨ì•½ì  ë¶„ì„ ê²°ê³¼
        """
        # ë¹„ë™ê¸° í•¨ìˆ˜ë¥¼ ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰
        try:
            # ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ ì´ë²¤íŠ¸ ë£¨í”„ê°€ ìˆëŠ”ì§€ í™•ì¸
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´ ìƒˆ íƒœìŠ¤í¬ë¡œ ì‹¤í–‰
                import nest_asyncio
                nest_asyncio.apply()
                return loop.run_until_complete(
                    self._async_analyze_dependency_vulnerabilities(dependencies, skip_unmapped)
                )
            else:
                return loop.run_until_complete(
                    self._async_analyze_dependency_vulnerabilities(dependencies, skip_unmapped)
                )
        except RuntimeError:
            # ì´ë²¤íŠ¸ ë£¨í”„ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
            return asyncio.run(
                self._async_analyze_dependency_vulnerabilities(dependencies, skip_unmapped)
            )

    def _severity_priority(self, severity: str) -> int:
        """ì‹¬ê°ë„ ìš°ì„ ìˆœìœ„ (ì •ë ¬ìš©)"""
        priority = {
            "CRITICAL": 0,
            "HIGH": 1,
            "MEDIUM": 2,
            "LOW": 3,
            "UNKNOWN": 4
        }
        return priority.get(severity, 5)

    def _generate_summary(
        self,
        vulnerabilities: List[Dict],
        severity_counts: Dict[str, int]
    ) -> str:
        """ì·¨ì•½ì  ìš”ì•½ ìƒì„±"""
        total = len(vulnerabilities)

        if total == 0:
            return "No vulnerabilities found. âœ…"

        critical = severity_counts.get("CRITICAL", 0)
        high = severity_counts.get("HIGH", 0)
        medium = severity_counts.get("MEDIUM", 0)
        low = severity_counts.get("LOW", 0)

        summary = f"Found {total} vulnerabilities: "
        parts = []

        if critical > 0:
            parts.append(f"{critical} CRITICAL âŒ")
        if high > 0:
            parts.append(f"{high} HIGH âš ï¸")
        if medium > 0:
            parts.append(f"{medium} MEDIUM âš¡")
        if low > 0:
            parts.append(f"{low} LOW â„¹ï¸")

        summary += ", ".join(parts)

        # ê¶Œì¥ì‚¬í•­
        if critical > 0:
            summary += "\nğŸš¨ IMMEDIATE ACTION REQUIRED: Critical vulnerabilities found!"
        elif high > 0:
            summary += "\nâš ï¸  High severity vulnerabilities require attention."

        return summary

    def format_vulnerability_report(
        self,
        vulnerabilities: List[Dict],
        format: str = "markdown"
    ) -> str:
        """
        ì·¨ì•½ì  ë¦¬í¬íŠ¸ ìƒì„±

        Args:
            vulnerabilities: ì·¨ì•½ì  ëª©ë¡
            format: ì¶œë ¥ í˜•ì‹ (markdown, json, text)

        Returns:
            í¬ë§·ëœ ë¦¬í¬íŠ¸
        """
        if format == "json":
            import json
            return json.dumps(vulnerabilities, indent=2, ensure_ascii=False)

        elif format == "markdown":
            lines = ["# Vulnerability Report\n"]

            for vuln in vulnerabilities:
                lines.append(f"## {vuln['cve_id']} - {vuln['severity']}")
                lines.append(f"**Package**: {vuln.get('package_name', 'N/A')} @ {vuln.get('package_version', 'N/A')}")
                lines.append(f"**CVSS Score**: {vuln.get('cvss_v3_score', 'N/A')}")
                lines.append(f"**Description**: {vuln['description'][:200]}...")
                lines.append(f"**Published**: {vuln['published']}")
                lines.append("")

            return "\n".join(lines)

        else:  # text
            lines = ["=== Vulnerability Report ===\n"]

            for vuln in vulnerabilities:
                lines.append(f"[{vuln['severity']}] {vuln['cve_id']}")
                lines.append(f"  Package: {vuln.get('package_name', 'N/A')} @ {vuln.get('package_version', 'N/A')}")
                lines.append(f"  CVSS: {vuln.get('cvss_v3_score', 'N/A')}")
                lines.append(f"  {vuln['description'][:150]}...")
                lines.append("")

            return "\n".join(lines)


# Helper function for direct use
def search_vulnerabilities(product: str, version: str = "*") -> Dict[str, Any]:
    """
    ê°„í¸ ê²€ìƒ‰ í•¨ìˆ˜

    Args:
        product: ì œí’ˆëª…
        version: ë²„ì „ (ê¸°ë³¸ê°’: * = ëª¨ë“  ë²„ì „)

    Returns:
        ì·¨ì•½ì  ëª©ë¡
    """
    client = NvdClient()
    return client.get_product_vulnerabilities(product, version)
